<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
<style type="text/css">
html { height: 100% }
body { height: 100%; margin: 0; padding: 0 }
</style>
<script type="text/javascript">


var map;
var latLongArray;
var polyline=null;
var polylineOptions;
var filenames = []; 
var files = []; 
var gpxhttp = [];
var xmlhttp;

var mapInitialized=false;
//var downloadTime=0;
//var renderTime=0;
//var startDownload=0;

if (typeof XMLHttpRequest === "undefined") {
  XMLHttpRequest = function () {
    try { return new ActiveXObject("Msxml2.XMLHTTP.6.0"); }
    catch (e) {}
    try { return new ActiveXObject("Msxml2.XMLHTTP.3.0"); }
    catch (e) {}
    try { return new ActiveXObject("Microsoft.XMLHTTP"); }
    catch (e) {}
    // Microsoft.XMLHTTP points to Msxml2.XMLHTTP and is redundant
    throw new Error("This browser does not support XMLHttpRequest.");
  };
}

function initializeMap() 
{
    if (!mapInitialized)
    {
        var mapOptions = {	center: new google.maps.LatLng(47.65, -122.10),
                            zoom: 10,
                            mapTypeId: google.maps.MapTypeId.ROADMAP };
        map = new google.maps.Map(document.getElementById("map_canvas"), mapOptions);
        mapInitialized=true;    
    }
}

function handleXml(gpxhttp, currentFile, currentFileIndex)
{
    if (gpxhttp.readyState == 4) // complete 
	{
        if (gpxhttp.status == 200) // OK
		{
            //var startRender = performance.now();
            //downloadTime = downloadTime + startRender - startDownload;

			var xmlDoc=gpxhttp.responseXML; 
			var xmlText=gpxhttp.responseText;
			document.getElementById('filename').innerHTML = currentFile.name;
			document.getElementById('currentFile').innerHTML = currentFileIndex+1;
			//document.getElementById('contents').innerHTML = xmlText;
			
			//if (xmlDoc == null)
			//{
            //    var parser = new DOMParser();
            //    xmlDoc = parser.parseFromString(xmlhttp.responseText, "text\/xml");
			//}
			
			var timeNodes = xmlDoc.getElementsByTagName('time');
			var timeValue = "";
			if (timeNodes.length == 0)
			{
				document.getElementById('time').innerHTML = "";
				document.getElementById('errors').innerHTML += "No time tag: " + currentFile.name + "\n";				
			}
			else
			{
				timeValue = timeNodes[0].firstChild.nodeValue;
				var date = new Date(timeValue);
				document.getElementById('time').innerHTML = date.toDateString();
				if (date.toDateString() != currentFile.date.toDateString())
				{
					document.getElementById('errors').innerHTML += "Date mismatch: " + currentFile.name + "contains " + date.toDateString() 
						+ " expected " + currentFile.date.toDateString()
						+ "\n";
				}
			}
			
			var nameNodes = xmlDoc.getElementsByTagName('name');
			if (nameNodes.length == 0)
			{
				document.getElementById('name').innerHTML = currentFile.name;
			}
			else
			{
				var nameValue = nameNodes[0].firstChild.nodeValue;
				if (nameValue != timeValue)
				{
					document.getElementById('name').innerHTML = nameValue;
				}
				else
				{
					document.getElementById('name').innerHTML = currentFile.name;
				}
			}
			
			var trkptNodes = xmlDoc.getElementsByTagName('trkpt');
			if (trkptNodes.length == 0)
			{
				//document.getElementById('trkpt').innerHTML = "invalid gpx, skip it."
				document.getElementById('errors').innerHTML += "Invalid gpx: " + currentFile.name + "\n";				
			}
			else
			{
				//document.getElementById('trkpt').innerHTML = trkptNodes.length + " trkpts";
				
				// Add the track points to the map
				latLongArray = new google.maps.MVCArray();
				var bounds = new google.maps.LatLngBounds();
				for (var i = 0; i < trkptNodes.length; ++i) 
				{
					var trkptNode = trkptNodes[i];
					var lat = trkptNode.attributes.getNamedItem("lat").value;
					var lon = trkptNode.attributes.getNamedItem("lon").value;

					
					var point = new google.maps.LatLng(lat,lon);
					latLongArray.push(point);
					bounds.extend(point);
				}
				//document.getElementById('trkpt').innerHTML += ", bounds=" + bounds.toString();				
								
				if (polyline!=null)
				{
					polylineOptions.strokeColor = "#FF0000";
					polyline.setOptions(polylineOptions);
				}
				polylineOptions = {
					path: latLongArray,
					strokeColor: "#0000FF",
					strokeOpacity: 1.0,
					strokeWeight: 2};
				polyline = new google.maps.Polyline(polylineOptions);
				polyline.setMap(map);

			}
            //renderTime = renderTime + performance.now() - startRender;
            //document.getElementById('errors').innerHTML += "download " + downloadTime + ", render " + renderTime + "\n";

//			if (currentFileIndex+1 < filenames.length)
//			{
//				currentFileIndex++;
//				readTrackData();
//			}
		}
	}		
}

function handleIndexXML()
{
    if (xmlhttp.readyState == 4) // complete 
	{
        if (xmlhttp.status == 200) // OK
		{
			xmlDoc=xmlhttp.responseXML;
			if (xmlDoc == null)
			{
				//document.getElementById('trkpt').innerHTML = "invalid XML!";
				document.getElementById('errors').innerHTML += "Invalid xml: allruns.xml\n";
				return;
			}
			var fileNodes = xmlDoc.getElementsByTagName('file');
			if (fileNodes.length == 0)
			{
				//document.getElementById('trkpt').innerHTML = "invalid xml, no file tag."
				document.getElementById('errors').innerHTML += "Invalid xml:  allruns.xml\n";				
				return;
			}

			//document.getElementById('tick').innerHTML = 'index read:";
			for (var i = 0; i < fileNodes.length; ++i) 
			{
				//document.getElementById('tick').innerHTML += i + ",";
				filenames[i] = fileNodes[i].getElementsByTagName('name')[0].firstChild.nodeValue;
				
				var timeValue = fileNodes[i].getElementsByTagName('date')[0].firstChild.nodeValue;
				var fileDate = new Date(timeValue);
				//sortedIndex[i] = i;
				files[i] = {date:fileDate, name:filenames[i]};
			}

			
			//document.getElementById('contents').innerHTML = filenames;
			document.getElementById('filename').innerHTML = filenames.length + " files";
			document.getElementById('fileCount').innerHTML = filenames.length;			
            
            readTrackData();
            

            initializeMap();
		}
	}
}

function readTrackData()
{
    //startDownload = performance.now();
	//
    
    for (file = 0; file < files.length; file++) { 
        gpxhttp[file]=new XMLHttpRequest();
        gpxhttp[file].open("GET","runs/"+files[file].name+".gz");
        gpxhttp[file].onreadystatechange = (function(i) { 
            return function() { handleXml(gpxhttp[i], files[i], i); } })(file);
        //gpxhttp.setRequestHeader('accept-encoding','gzip');
        //gpxhttp.overrideMimeType('text\/xml; charset=x-user-defined');   
        gpxhttp[file].send();
    }    
}

</script>
</head>

<body>

<script type="text/javascript">
xmlhttp=new XMLHttpRequest();
xmlhttp.open("GET","allruns.xml");
xmlhttp.onreadystatechange = handleIndexXML;
xmlhttp.send();
</script>
<script type="text/javascript"
src="http://maps.googleapis.com/maps/api/js?key=AIzaSyCyM0mrFrvnIbYkve4hWKY30cjVqY8VnMU&callback=initializeMap" async defer>
</script>

<div id="header" style="width:100%; height:10%;overflow:auto;">
<!-- <textarea id=tick>no tick</textarea><br> -->

<span id=name> </span><br/>
<span id=time> </span><br/>
(<span id=currentFile>0</span>&#x2F;<span id=fileCount>0</span>)
<P id=filename> </P>
<textarea id=errors>Errors:
</textarea>
<br/>
<textarea id=index></textarea>
</div>

<div id="map_canvas" style="width:100%; height:90%"></div>

</body>
</html>
